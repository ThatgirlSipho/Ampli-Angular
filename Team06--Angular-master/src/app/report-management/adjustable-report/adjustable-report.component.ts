import { Component, OnInit } from '@angular/core';
import { DataService } from 'src/app/services/data.service';
import { jsPDF } from 'jspdf';
import 'jspdf-autotable';
import { Client } from 'src/app/services/model';


@Component({
  selector: 'app-adjustable-report',
  templateUrl: './adjustable-report.component.html',
  styleUrls: ['./adjustable-report.component.css']
})
export class AdjustableReportComponent implements OnInit {

  clients: Client[] = [];
  filteredClients: Client[] = [];
  startDateFilter: string = '';
  endDateFilter: string = '';
  reportGeneratorName: string = '';
  reportGeneratorRole: string = '';

  constructor(private dataservice: DataService) {}

  ngOnInit(): void {
    this.dataservice.GetAllClients().subscribe(
      data => {
        console.log('Fetched clients:', data); // Verify data here
        if (Array.isArray(data)) {
          this.clients = data;
          this.filteredClients = data;
        } else {
          console.error('Expected an array but received:', data);
          this.clients = [];
          this.filteredClients = [];
        }
        this.getReportGenerator(); // Fetch the report generator's details
      },
      error => {
        console.error('Error fetching clients', error);
      }
    );
  }

  filterClients(): void {
    const startDate = this.startDateFilter ? new Date(this.startDateFilter) : null;
    const endDate = this.endDateFilter ? new Date(this.endDateFilter) : null;

    if (startDate) startDate.setHours(0, 0, 0, 0);
    if (endDate) endDate.setHours(23, 59, 59, 999);

    this.filteredClients = this.clients.filter(client => {
      const clientDate = new Date(client.dateJoined);
      return (!startDate || clientDate >= startDate) && (!endDate || clientDate <= endDate);
    });
  }

  clearFilter(): void {
    this.startDateFilter = '';
    this.endDateFilter = '';
    this.filteredClients = this.clients;
  }

  getReportGenerator(): void {
    this.dataservice.getCurrentUser().subscribe(
      (employee: any) => {
        this.reportGeneratorName = employee.fullName;
        this.reportGeneratorRole = employee.role;
      },
      (error) => {
        console.error('Error fetching employee data', error);
      }
    );
  }

  generatePDF(): void {
    if (!Array.isArray(this.filteredClients)) {
      console.error('Filtered clients is not an array:', this.filteredClients);
      return;
    }

    const doc = new jsPDF();

       // Add background image
  const backgroundImage = new Image();
  backgroundImage.src = '/assets/Portrait Dashboard.png'; 
  doc.addImage(backgroundImage, 'PNG', 0, 0, 210, 297); 
  
    // Add title
    doc.setFontSize(18);
    doc.text('Report on Number of Applicants on Date Joined', 14, 20);

    // Add report generation date
    doc.setFontSize(12);
    doc.text(`Report Generation Date: ${new Date().toLocaleDateString()}`, 14, 30);

    // Combine the generator's name and role
    const generatorText = `Generated by: ${this.reportGeneratorName}, ${this.reportGeneratorRole}`;

    // Add generator's details
    doc.text(generatorText, 14, 40);

    // Prepare table data
    const startY = 50;
    const tableHeaders = ['Client ID', 'Client Name', 'Date Joined'];

    const tableRows = this.filteredClients.map(client => [
      client.clientId.toString(),
      client.fullName || 'No Full Name', // Handle missing fullName
      new Date(client.dateJoined).toLocaleDateString()
    ]);

    // Add filtered clients table
    (doc as any).autoTable({
      startY: startY,
      head: [tableHeaders],
      body: tableRows,
      theme: 'striped',
      headStyles: { fillColor: [0, 0, 129] },
      columnStyles: {
        0: { cellWidth: 30 },
        1: { cellWidth: 60 },
        2: { cellWidth: 40 }
      }
    });

    // Generate the PDF as a Blob
    const pdfBlob = doc.output('blob');

    // Create a URL for the Blob
    const pdfUrl = URL.createObjectURL(pdfBlob);

    // Open the PDF in a new tab/window
    window.open(pdfUrl);
  }
}
